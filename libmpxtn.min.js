"use strict";class heapmemory{constructor(t,e,s,i=4){this.top=Number(t),this.size=Number(e),this.memory=s,this.align=i,this.ftable={0:this.size},this.atable={}}resize(t,e){this.top=Number(t),this.size=Number(e),this.ftable={0:this.size},this.atable={}}clear(){this.ftable={0:this.size},this.atable={}}tabledump(){console.log("alloc"),console.log(this.atable),console.log("free"),console.log(this.ftable)}allocated(t){return(t=Number(t))in this.ftable}allocated_bytes(){let t=0;for(let e in this.atable)t+=this.atable[e];return t}freetable(){return this.ftable}check_fwdspace(t){if(t=Number(t),!this.allocated(t))return;const e=t+Number(this.ftable[t]);e in this.ftable&&(this.ftable[t]+=this.ftable[e],delete this.ftable[e])}check_bwdspace(t){t=Number(t);const e=Object.keys(this.ftable).sort((t,e)=>Number(t)-Number(e)),s=Number(e.indexOf(t.toString()));if(s>0){const i=Number(e[s-1]);i+this.ftable[i]==t&&(this.ftable[i]+=this.ftable[t],delete this.ftable[t])}}aligned(t){const e=t%this.align;return 0==e?t:t+(this.align-e)}malloc(t){let e=null;t=this.aligned(t);for(let s in this.ftable)s=Number(s),t<=this.ftable[s]&&(this.atable[s]=t,t<this.ftable[s]&&(this.ftable[s+t]=this.ftable[s]-t),delete this.ftable[s],e=this.top+s);if(null==e)return 0;let s=new Uint8Array(this.memory.buffer);for(let i=0;i<t;++i)s[e+i]=0;return e}free(t){const e=Number(t-this.top);e in this.atable&&(this.ftable[e]=this.atable[e],delete this.atable[e],this.check_fwdspace(e),this.check_bwdspace(e))}realloc(t,e){if(0==t)return this.malloc(t);const s=t-this.top;if(s in this.atable){if(0==(e=this.aligned(e)))return free(t),0;if(e<=this.atable[s]){if(e<this.atable[s]){const t=s+e;this.ftable[t]=this.ftable[s]-e,this.check_fwdspace(t)}return t}const i=s+this.atable[s];if(i in this.ftable){const h=this.atable[s]+this.ftable[i];if(e<=h){if(this.atable[s]=e,e<h){const t=s+e;this.ftable[t]=h-e}return delete this.ftable[i],t}}const h=this.malloc(e);if(h>0){let e=new Uint8Array(this.memory.buffer);for(let i=0;i<this.atable[s];++i)e[h+i]=e[t+i];return this.free(t),h}}return null}}class libmpxtn{constructor(t,e,s){this.memsize=t,this.globalsize=262144,this.stacksize=1048576,this.buffersize=e,this.filesize=0,this.heapsize=0,this.calc_top(),this.memory=new WebAssembly.Memory({initial:this.memsize/64/1024}),this.heap=new heapmemory(this.heaptop,this.heapsize,this.memory,4),this.mpxtnobj=0,this.imports={imports:{}},this.exports={},this.path=s,this.imports.env={memory:this.memory,malloc:t=>this.heap.malloc(t),realloc:(t,e)=>this.heap.realloc(t,e),free:t=>this.heap.free(t)}}calc_top(){this.stacktop=this.globalsize,this.buffertop=this.stacktop+this.stacksize,this.filetop=this.buffertop+this.buffersize,this.heaptop=this.filetop+this.filesize,this.heapsize=this.memsize-this.heaptop}load_wasm(){return new Promise((t,e)=>{fetch(this.path).then(t=>t.arrayBuffer()).then(t=>WebAssembly.instantiate(t,this.imports)).then(e=>{this.exports=e.instance.exports,t(e)})})}heap_usage(){return{size:this.heapsize,allocated:this.heap.allocated_bytes(),free:this.heap.freetable()}}clear(){this.mpxtnobj=0,this.heap.clear()}set_file(t,e){this.filesize=e,this.calc_top();const s=new Uint8Array(t);let i=new Uint8Array(this.memory.buffer);for(let t=0;t<this.filesize;++t)i[this.filetop+t]=s[t];this.mpxtnobj=0,this.heap.resize(this.heaptop,this.heapsize)}get ready(){return this.mpxtnobj>0}mpxtn_mread(){return this.mpxtnobj=this.exports.mpxtn_mread(this.filetop,this.filesize,0),this.mpxtnobj>0}mpxtn_reset(){return 0==this.mpxtnobj?null:this.exports.mpxtn_reset(this.mpxtnobj)}mpxtn_get_total_samples(){return 0==this.mpxtnobj?null:this.exports.mpxtn_get_total_samples(this.mpxtnobj)}mpxtn_get_current_sample(){return 0==this.mpxtnobj?null:this.exports.mpxtn_get_current_sample(this.mpxtnobj)}mpxtn_get_repeat_sample(){return 0==this.mpxtnobj?null:this.exports.mpxtn_get_repeat_sample(this.mpxtnobj)}mpxtn_set_loop(t){return 0==this.mpxtnobj?null:this.exports.mpxtn_set_loop(this.mpxtnobj,Boolean(t))}mpxtn_get_loop(){return 0==this.mpxtnobj?null:this.exports.mpxtn_get_loop(this.mpxtnobj)}mpxtn_vomit(){return 0==this.mpxtnobj?null:(this.exports.mpxtn_vomit(this.buffertop,this.buffersize/4,this.mpxtnobj),this.memory.buffer.slice(this.buffertop,this.buffertop+this.buffersize))}mpxtn_vomit_feeder(){if(0==this.mpxtnobj)return null;const t=this.buffertop+this.buffersize/2;return this.exports.mpxtn_vomit_feeder(this.buffertop,this.buffersize/8,this.mpxtnobj),[new Float32Array(this.memory.buffer.slice(this.buffertop,t)),new Float32Array(this.memory.buffer.slice(t,this.buffertop+this.buffersize))]}dump_pcm(){if(0==this.mpxtnobj)return null;this.mpxtn_reset(),this.mpxtn_set_loop(!1);const t=this.buffersize/4,e=this.mpxtn_get_total_samples();let s=new ArrayBuffer(44+4*e),i=new DataView(s);i.setUint32(0,1380533830,!1),i.setUint32(4,36+4*e,!0),i.setUint32(8,1463899717,!1),i.setUint32(12,1718449184,!1),i.setUint32(16,16,!0),i.setUint16(20,1,!0),i.setUint16(22,2,!0),i.setUint32(24,44100,!0),i.setUint32(28,176400,!0),i.setUint16(32,4,!0),i.setUint16(34,16,!0),i.setUint32(36,1684108385,!1),i.setUint32(40,4*e,!0);let h=new Uint32Array(s);for(let s=0;s<e;s+=t){const i=new Uint32Array(this.mpxtn_vomit());for(let r=0;r<t&&s+r<e;++r)h[44+s+r]=i[r]}return s}}